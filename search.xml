<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[创建一个自定义GSource]]></title>
    <url>%2F2018%2F07%2F18%2FLinux%2F%E8%87%AA%E5%AE%9A%E4%B9%89Gsource%2F</url>
    <content type="text"><![CDATA[Glib实现了强大的事件循环分发处理机制，即为GMainLoop。GMainLoop工作于指定的GMainContext，GMainContext有一个GSource列表。GLib 内部定义实现了三种类型的事件源，分别是 Idle, Timeout 和 I/O。同时也支持创建自定义的事件源。 自定义事件源可以将外部事件挂到指定的GMainLoop中，总而在g_main_loop_run时候相应。 首先定义事件源结构体，第一个成员是GSource，其后再是所需数据。1234567typedef struct _MySource MySource; struct _MySource&#123; GSource _source; gchar text[256];&#125; 还要实现GSourceFuncs结构。结构内注册回调函数。123456789struct GSourceFuncs &#123; gboolean (*prepare) (GSource *source, gint *timeout_); gboolean (*check) (GSource *source); gboolean (*dispatch) (GSource *source, GSourceFunc callback, gpointer user_data); void (*finalize) (GSource *source); /* Can be NULL */&#125;; 将 GSourceFuncs 结构+事件源结构的存储空间宽度作为参数传给 g_source_new 便可构造一个新的事件源,继而可使用 g_source_attach 函数将新的事件源添加到主循环上下文中。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
        <tag>GMainLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO复用中的3个函数]]></title>
    <url>%2F2018%2F07%2F18%2FLinux%2FIO%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[IO复用历史背景：服务器不可能为每一个客户请求产生一个进程，开销太大。因此引入IO复用，即 一个进程可以同时对多个客户进行服务 复用一个进程对多个IO服务，进程系统调用select和poll。内核一旦发现进程指定的一个或多个IO条件满足，就通知进程。 select函数int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout); maxfdp1 : [0,maxfdp1-1]这些描述符都将被测试 readset, writeset, exceptset :指定要让内核测试读、写、异常条件的fd set，描述符集可以被4个宏操作设定。 void FD_ZERO(fd_set *fdset);//清空集合 void FD_SET(int fd, fd_set *fdset);//将一个给定的文件描述符加入集合之中 void FD_CLR(int fd, fd_set *fdset);//将一个给定的文件描述符从集合中删除 int FD_ISSET(int fd, fd_set *fdset);// 检查集合中指定的文件描述符是否是可以读写的 timeout ： 等待fd中的任何一个就绪可花时间。 设置为NULL，永远等待 设置为固定时间t，t之内有一个fd准备好IO则返回 timeval设置0，不等待，检查完了即返回，此为轮询 select的缺点在于： 1.每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态,在内核遍历传递进来的set中的所有 fd.这个开销在 fd 很多时会很大,线性增长.2.单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。 example程序:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;sys/select.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char *argv[])&#123; fd_set rfds; struct timeval tv; int ret; int fd; ret = mkfifo("test_fifo", 0666); // 创建有名管道 if(ret != 0)&#123; perror("mkfifo："); &#125; fd = open("test_fifo", O_RDWR); // 读写方式打开管道 if(fd &lt; 0)&#123; perror("open fifo"); return -1; &#125; ret = 0; while(1)&#123; // 这部分内容，要放在while(1)里面 FD_ZERO(&amp;rfds); // 清空 FD_SET(0, &amp;rfds); // 标准输入描述符 0 加入集合 FD_SET(fd, &amp;rfds); // 有名管道描述符 fd 加入集合 // 超时设置 tv.tv_sec = 1; tv.tv_usec = 0; // 监视并等待多个文件（标准输入，有名管道）描述符的属性变化（是否可读） // 没有属性变化，这个函数会阻塞，直到有变化才往下执行，这里没有设置超时 // FD_SETSIZE 为 &lt;sys/select.h&gt; 的宏定义，值为 1024 ret = select(FD_SETSIZE, &amp;rfds, NULL, NULL, NULL); //ret = select(FD_SETSIZE, &amp;rfds, NULL, NULL, &amp;tv); //存在文件描述符的属性发生变化,select返回,使用FD_ISSET()检测是否是可读.若可读,则使用read读到初始化的buffer if(ret == -1)&#123; // 出错 perror("select()"); &#125;else if(ret &gt; 0)&#123; // 准备就绪的文件描述符 char buf[100] = &#123;0&#125;; if( FD_ISSET(0, &amp;rfds) )&#123; // 标准输入 read(0, buf, sizeof(buf)); printf("stdin buf = %s\n", buf); &#125;else if( FD_ISSET(fd, &amp;rfds) )&#123; // 有名管道 read(fd, buf, sizeof(buf)); printf("fifo buf = %s\n", buf); &#125; &#125;else if(0 == ret)&#123; // 超时 printf("time out\n"); &#125; &#125; return 0;&#125; 以下程序向有名管道写数据.1234567891011121314151617181920212223242526272829303132333435#include &lt;sys/select.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; //select_demo(8); fd_set rfds; struct timeval tv; int ret; int fd; ret = mkfifo("test_fifo", 0666); // 创建有名管道 if(ret != 0)&#123; perror("mkfifo："); &#125; fd = open("test_fifo", O_RDWR); // 读写方式打开管道 if(fd &lt; 0)&#123; perror("open fifo"); return -1; &#125; while(1)&#123; char *str = "this is for test"; write(fd, str, strlen(str)); // 往管道里写内容 printf("after write to fifo\n"); sleep(5); &#125; return 0;&#125; poll函数 poll()本质和select类似. 没有最大文件描述符数量的限制（但是数量过大后性能也是会下降）。poll() 和 select() 同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 除了描述fdset的方式有区别以外,select和poll没什么差别. int poll(struct pollfd *fds, nfds_t nfds, int timeout);不同于select使用三个独立的fdset表示三种事件类型, poll()只有一个fd set. pollfd包括文件描述符和事件, 调用者指定event(事件掩码),告诉内核应该关注什么事件.内核返回时候设置revent,为实际发生的事件.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485struct pollfd&#123;int fd; /* 文件描述符 */short events; /* 等待的事件 */short revents; /* 实际发生了的事件 */&#125;;``` 处理输入：&gt;POLLIN 普通或优先级带数据可读 POLLRDNORM 普通数据可读POLLRDBAND 优先级带数据可读POLLPRI 高优先级数据可读处理输出：&gt;POLLOUT 普通数据可写POLLWRNORM 普通数据可写POLLWRBAND 优先级带数据可写处理错误：&gt;POLLERR发生错误POLLHUP发生挂起POLLVAL 描述字不是一个打开的文件`poll` pollin | pollpri == `select` 读事件`poll` pollout | pollwrband == `select` 写事件示例程序```c#include &lt;poll.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[])&#123; int ret; int fd; struct pollfd fds[2]; // 监视文件描述符结构体，2 个元素 ret = mkfifo(&quot;test_fifo&quot;, 0666); // 创建有名管道 if(ret != 0)&#123; perror(&quot;mkfifo：&quot;); &#125; fd = open(&quot;test_fifo&quot;, O_RDWR); // 读写方式打开管道 if(fd &lt; 0)&#123; perror(&quot;open fifo&quot;); return -1; &#125; ret = 0; fds[0].fd = 0; // 标准输入 fds[1].fd = fd; // 有名管道 fds[0].events = POLLIN; // 普通或优先级带数据可读 fds[1].events = POLLIN; // 普通或优先级带数据可读 while(1)&#123; // 监视并等待多个文件（标准输入，有名管道）描述符的属性变化（是否可读） // 没有属性变化，这个函数会阻塞，直到有变化才往下执行，这里没有设置超时 ret = poll(fds, 2, -1); //ret = poll(&amp;fd, 2, 1000); if(ret == -1)&#123; // 出错 perror(&quot;poll()&quot;); &#125;else if(ret &gt; 0)&#123; // 准备就绪的文件描述符 char buf[100] = &#123;0&#125;; if( ( fds[0].revents &amp; POLLIN ) == POLLIN )&#123; // 标准输入 read(0, buf, sizeof(buf)); printf(&quot;stdin buf = %s\n&quot;, buf); &#125;else if( ( fds[1].revents &amp; POLLIN ) == POLLIN )&#123; // 有名管道 read(fd, buf, sizeof(buf)); printf(&quot;fifo buf = %s\n&quot;, buf); &#125; &#125;else if(0 == ret)&#123; // 超时 printf(&quot;time out\n&quot;); &#125; &#125; return 0;&#125; epoll函数不再使用fd set,而是只使用一个epoll fd(epfd)来指向存放在内核的fd set.这样就避免了每次都在用户空间指定fd set再拷贝到内核空间. 1234#include &lt;sys/epoll.h&gt;int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 使用这三个接口使用epoll int epoll_create(int size); 创建epfd,并返回. size参数在2.6.8版本后不用考虑. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epfd: epoll_create的返回值op: EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；EPOLL_CTL_DEL：从 epfd 中删除一个 fd；EPOLL_CTL_MOD：修改已经注册的fd的监听事件； fd: 本次操作指定的fdevent: 本次操作指定的事件12345678910111213// 保存触发事件的某个文件描述符相关的数据（与具体使用方式有关）typedef union epoll_data &#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;&#125; epoll_data_t;// 感兴趣的事件和被触发的事件struct epoll_event &#123; __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;; events 可以是以下的事件集合. EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；EPOLLOUT：表示对应的文件描述符可以写；EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；EPOLLERR：表示对应的文件描述符发生错误；EPOLLHUP：表示对应的文件描述符被挂断；EPOLLET ：将 EPOLL 设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里 int epoll_wait( int epfd, struct epoll_event * events, int maxevents, int timeout );类似于select,收集epfd中发生的事件.epoll会把发生的事件复制到events数组中,这个数组需要预分配. 示例程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;sys/epoll.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[])&#123; int ret; int fd; ret = mkfifo("test_fifo", 0666); // 创建有名管道 if(ret != 0)&#123; perror("mkfifo："); &#125; fd = open("test_fifo", O_RDWR); // 读写方式打开管道 if(fd &lt; 0)&#123; perror("open fifo"); return -1; &#125; ret = 0; struct epoll_event event; // 告诉内核要监听什么事件 struct epoll_event wait_event; int epfd = epoll_create(10); // 创建一个 epoll 的句柄，参数要大于 0， 没有太大意义 if( -1 == epfd )&#123; perror ("epoll_create"); return -1; &#125; event.data.fd = 0; // 标准输入 event.events = EPOLLIN; // 表示对应的文件描述符可以读 // 事件注册函数，将标准输入描述符 0 加入监听事件 ret = epoll_ctl(epfd, EPOLL_CTL_ADD, 0, &amp;event); if(-1 == ret)&#123; perror("epoll_ctl"); return -1; &#125; event.data.fd = fd; // 有名管道 event.events = EPOLLIN; // 表示对应的文件描述符可以读 // 事件注册函数，将有名管道描述符 fd 加入监听事件 ret = epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event); if(-1 == ret)&#123; perror("epoll_ctl"); return -1; &#125; ret = 0; while(1)&#123; // 监视并等待多个文件（标准输入，有名管道）描述符的属性变化（是否可读） // 没有属性变化，这个函数会阻塞，直到有变化才往下执行，这里没有设置超时 ret = epoll_wait(epfd, &amp;wait_event, 2, -1); //ret = epoll_wait(epfd, &amp;wait_event, 2, 1000); if(ret == -1)&#123; // 出错 close(epfd); perror("epoll"); &#125;else if(ret &gt; 0)&#123; // 准备就绪的文件描述符 char buf[100] = &#123;0&#125;; if( ( 0 == wait_event.data.fd ) &amp;&amp; ( EPOLLIN == wait_event.events &amp; EPOLLIN ) )&#123; // 标准输入 read(0, buf, sizeof(buf)); printf("stdin buf = %s\n", buf); &#125;else if( ( fd == wait_event.data.fd ) &amp;&amp; ( EPOLLIN == wait_event.events &amp; EPOLLIN ) )&#123; // 有名管道 read(fd, buf, sizeof(buf)); printf("fifo buf = %s\n", buf); &#125; &#125;else if(0 == ret)&#123; // 超时 printf("time out\n"); &#125; &#125; close(epfd); return 0;&#125; 优势: 1）监视的描述符数量不受限制，它所支持的 FD 上限是最大可以打开文件的数目，这个数字一般远大于 2048,举个例子,在 1GB 内存的机器上大约是 10 万左右，具体数目可以 cat /proc/sys/fs/file-max 察看,一般来说这个数目和系统内存关系很大。select() 的最大缺点就是进程打开的 fd 是有数量限制的。这对于连接数量比较大的服务器来说根本不能满足。 2)I/O 的效率不会随着监视 fd 的数量的增长而下降。select()，poll() 实现需要自己不断轮询所有 fd 集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而 epoll 其实也需要调用 epoll_wait() 不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪 fd 放入就绪链表中，并唤醒在 epoll_wait() 中进入睡眠的进程。虽然都要睡眠和交替，但是 select() 和 poll() 在“醒着”的时候要遍历整个 fd 集合，而 epoll 在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的 CPU 时间。这就是回调机制带来的性能提升。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GMainloop]]></title>
    <url>%2F2018%2F07%2F18%2FLinux%2FGmainloop%2F</url>
    <content type="text"><![CDATA[Backgroundevent loop是coding中的一个基础模型。代码基础是I/O多路复用中的三个函数：select, poll和epoll。 glib是一个跨平台的库，在linux上，使用的是poll函数，在window上，使用的是select。而epoll这个接口，在linux2.6中才正式推出，它的效率，比前两者更高，在网络编程中大量使用。而本质上，这三个函数，其实是相同的。 看一段简单的使用poll的实现。1234567891011121314151617181920212223242526272829struct pollfd fds[2]; //预先分配两个pollfd结构int timeout_msecs = 500; //注意到这里的timeout为统一值int ret;int i;/* Open STREAMS device. 打开设备，初始fd和待检测的事件*/fds[0].fd = open("/dev/dev0", ...);fds[1].fd = open("/dev/dev1", ...);fds[0].events = POLLOUT | POLLWRBAND;fds[1].events = POLLOUT | POLLWRBAND;while(1) &#123; ret = poll(fds, 2, timeout_msecs); if (ret &gt; 0) &#123; /* An event on one of the fds has occurred. */ for (i=0; i&lt;2; i++) &#123; //遍历fd， if (fds[i].revents &amp; POLLWRBAND) &#123; /* Priority data may be written on device number i. */ ... ///执行该条件下的操作。 &#125; if (fds[i].revents &amp; POLLOUT) &#123; /* Data may be written on device number i. */ ... &#125; if (fds[i].revents &amp; POLLHUP) &#123; /* A hangup has occurred on device number i. */ ... &#125; &#125; &#125;&#125; 代码分为三部分： 1.分配pollfd并且初始化，即指定fd和对应的待检测事件。2.循环poll。3.对于每个fd，检查revent，并执行相应操作。 这段代码有几个缺点： 1.无法动态添加或删除pollfd2.poll()中调用的参数timeout是预先设置的固定值，循环调用时候，每个pollfd都使用同样的超时阈值。3.前面的代码，在poll返回时，假如有100个fd，则只能按照顺序依次check revent，没有优先级。可能会导致紧急事件拖后，短时间内得不到满足。 1.针对1，构造类统一管理所有的pollfd的，负责添加或者删除的类A。2.针对2，构造管理每一个pollfd的timeout的类B。3.针对3，构造管理每一个pollfd的优先级的类B。 这样A实际上是B的容器，管理B。 在GMainloop中，GContext相当于A，GSource相当于类B。 Gsource保存优先级信息，以链表形式管理pollfd，所以是1对n(n &gt;= 0).作为抽象类，包含三个纯虚函数。 gboolean (*prepare) (GSource *source, gint *timeout_);before poll()，该GSource中的struct pollfd是否希望被poll函数监控，就由prepare函数的返回值来决定。同时，该GSource希望的超时时间，也由参数timeout_返回。需要提前设置source的fd和event。 gboolean (*check) (GSource *source);after poll( )，检查pollfd的返回信息，若有事件发生，返回1.gboolean (*dispatch) (GSource *source, GSourceFunc callback, gpointer user_data);after poll() &amp;&amp; check(), 加入check返回true，则执行对应的dispatch。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void g_main_loop_run (GMainLoop *loop)&#123; GThread *self = G_THREAD_SELF; g_return_if_fail (loop != NULL); g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0); g_atomic_int_inc (&amp;loop-&gt;ref_count); loop-&gt;is_running = TRUE; while (loop-&gt;is_running) g_main_context_iterate (loop-&gt;context, TRUE, TRUE, self); UNLOCK_CONTEXT (loop-&gt;context); g_main_loop_unref (loop);&#125;static gboolean g_main_context_iterate(GMainContext *context, gboolean block, gboolean dispatch, GThread *self) &#123; gint max_priority; gint timeout; gboolean some_ready; gint nfds, allocated_nfds; GPollFD *fds = NULL; UNLOCK_CONTEXT (context); if (!context-&gt;cached_poll_array) &#123; context-&gt;cached_poll_array_size = context-&gt;n_poll_records; context-&gt;cached_poll_array = g_new (GPollFD, context-&gt;n_poll_records); &#125; allocated_nfds = context-&gt;cached_poll_array_size; fds = context-&gt;cached_poll_array; UNLOCK_CONTEXT (context); g_main_context_prepare(context, &amp;max_priority); while ((nfds = g_main_context_query(context, max_priority, &amp;timeout, fds, allocated_nfds)) &gt; allocated_nfds) &#123; LOCK_CONTEXT (context); g_free(fds); context-&gt;cached_poll_array_size = allocated_nfds = nfds; context-&gt;cached_poll_array = fds = g_new (GPollFD, nfds); UNLOCK_CONTEXT (context); &#125; if (!block) timeout = 0; g_main_context_poll(context, timeout, max_priority, fds, nfds); some_ready = g_main_context_check(context, max_priority, fds, nfds); if (dispatch) g_main_context_dispatch(context); LOCK_CONTEXT (context); return some_ready;&#125; 这段代码反映了glib的处理方式：调用g_main_context_prepare(context, &amp;max_priority)line 28，即遍历所有GSource，依次调用prepare，返回max_priority。并且调用g_main_context_query，遍历所有GSource，将优先级是max_priority的GSource加入到poll的检测set。 调用poll，g_main_context_poll。之后check每个source，选出check返回true的GSource，即事件发生的GSource。添加到一个内部链表中。 调用g_main_context_dispatch(context)。 官方文档摘： URL： https://developer.gnome.org/glib/2.56/glib-The-Main-Event-Loop.html#g-source-add-poll To allow multiple independent sets of sources to be handled in different threads, each source is associated with a GMainContext. A GMainContext can only be running in a single thread, but sources can be added to it and removed from it from other threads. Each event source is assigned a priority. The default priority, G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities. Values greater than 0 denote lower priorities. Events from high priority sources are always processed before events from lower priority sources. The GMainLoop data type represents a main event loop. A GMainLoop is created with g_main_loop_new(). After adding the initial event sources, g_main_loop_run() is called. This continuously checks for new events from each of the event sources and dispatches them. Finally, the processing of an event from one of the sources leads to a call to g_main_loop_quit() to exit the main loop, and g_main_loop_run() returns. Creating new source typesOne of the unusual features of the GMainLoop functionality is that new types of event source can be created and used in addition to the builtin type of event source. A new event source type is used for handling GDK events. A new source type is created by “deriving” from the GSource structure. The derived type of source is represented by a structure that has the GSource structure as a first element, and other elements specific to the new source type. To create an instance of the new source type, call g_source_new() passing in the size of the derived structure and a table of functions. These GSourceFuncs determine the behavior of the new source type.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
        <tag>GMainLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暴走行 in Russia]]></title>
    <url>%2F2018%2F06%2F29%2F%E9%95%9C%E5%A4%B4%E5%90%8E%E7%9A%84%E8%A7%86%E7%95%8C%2F%E6%9A%B4%E8%B5%B0%E8%A1%8C1%2F</url>
    <content type="text"><![CDATA[Background: Rob和Andy两位旁友很早就买了德国VS韩国的小组赛票，后来被他们游说，心动，遂在闲鱼买到了票，一同前往。对于没有暑假的我来说，6月份的这一趟，就是我的毕业旅行了~ 在俄航长达8小时的旅途后，半梦半醒之间，三人终于抵达了莫斯科机场。经济舱的座位啊，腿都没办法打直，我的膝盖在抗议。随后我们直接转坐高铁北上，去了圣彼得堡，俄罗斯的旧都，历史文化名城。St. Peterburg也是我们旅途的第一站。 住宿是在Airbnb上的民宿，房东老太太是少有的懂一点英语的老俄罗斯人。遇到长句子没法交流的时候就使用谷歌翻译的语音翻译，精准程度666。 俄罗斯的英语普及率类似中国。遇到的绝大部分老年人是几乎不懂英语的，所以交流只剩下了手势和最简单的词汇。但是年轻一代英语感觉水平还行。同行的小涛Andy来之前把俄罗斯字母认全了，俄语很多词语可以读出来，然后发音和英语几乎一致。比如кафе就是cafe之类的，其实就是外来词吧。某种意义上来说，这些外来词时不时的出现，给我们的行程带来了一些便利。 隔壁房间住的是两个埃及球迷，住的三四天一直很巧没遇到，直到最后他们整理行李离开才碰到，说是去过北京。小组赛第二场埃及输了，确定无法出局。在涅瓦大街路上遇到的埃及人们，几乎半数都穿着民族英雄，英超金靴萨拉赫的球衣，球迷还在路上挥舞印着萨拉赫的大旗帜，民族英雄的待遇啊。 住处附近有一家连锁小超市，我们在第一天就发现了这家的东西几乎不要钱。遂开始打劫。 比如2L的冰柜鲜牛奶，相当香浓。55卢布。 汇率：10卢布 == 1RMB，除以10就对了。真空包装红肠￥5-10，猪肉罐头￥5等等，这家就像是古老的5元平价超市，关乎食物基本都是5元10元的东西。 当一家超市东西很便宜的时候，你还会纠结买不买么，纠结的时候，买就对了，反正不要钱。 我们吃了什么作为一个吃货当然要先介绍俄罗斯当地的饮食。 前面提到了超市，有超市就有食材。吐司+蟹肉棒+奶酪+黄瓜+培根+鸡蛋之类的。下面是早餐的改良route。 上图： 我们基本是吃个早饭，白天四处暴走，午后找个地方歇一下吃超市买的零食，晚上那顿吃点好的。 我们第一天晚上吃了一家叫做喀秋莎的餐厅，餐厅里还有电视，看了德国的第一场失利以及巴西的第一场。 关于喀秋莎：这是一首地位很高的俄罗斯歌曲，诞生于卫国战争时期，大概是一群年轻士兵前往前线之前，年轻的学院姑娘们为他们唱的临别歌。后来的牺牲证明这群士兵的任务就是拖延时间争取战机，一群甚至未曾享受过恋爱甜蜜的少年就这样踏上了不归的征途，临走前听到姑娘们的歌声，心里该是几多感慨。 算是西餐厅，菜单大概是按照starter，salad，soup，main course, dessert, drink这样的顺序排列的。不过有些RU特色食物，比如红菜汤，汤色紫红，味道稍甜，还可以拌酸奶酱进去再喝。我觉得还挺好喝的，小伙伴们好像表情略微妙。第一次尝到了烤鹿肉(venison loin)，淋着蓝莓汁，摆盘很好看，但是还是架不住腥味，加上选的medium火候不是很熟，吃的过程中感觉自己仿佛拿着刀叉的原始人，真·野味。]]></content>
      <categories>
        <category>镜头后的视界</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>旅行</tag>
        <tag>俄罗斯</tag>
        <tag>圣彼得堡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drops cast in Australia(下篇)]]></title>
    <url>%2F2018%2F06%2F16%2F%E9%95%9C%E5%A4%B4%E5%90%8E%E7%9A%84%E8%A7%86%E7%95%8C%2FDrops2%2F</url>
    <content type="text"><![CDATA[悉尼歌剧院附近的海港大桥 我是拍了歌剧院的来着，但是太丑了啊啊。。随手拍就是这个毛病，根本是走到一个点突然发现这里可以拍，拍之前毫无构思。 悉尼的Bondi Beach迎来日出 我们就住在Bondi Beach边上的民宿里，鞋都没穿光着脚就跑到沙滩去了，刚好赶上日出。其实还拍了很多日出剪影来着嘿嘿。 无处安放的我的爱靴。 悉尼西侧的蓝山国家公园 到了山脚下瞬间气温特别低，不得不在当地的店里买了很丑的外套保暖，续命要紧。 Sydney Tower Eye旋转餐厅 可以看到整个悉尼城区傍晚和入夜的景色，美中不足是拍照的话隔着玻璃有点反光。 墨尔本！大洋路和12门徒岩 这个炫酷的地方有一个炫酷的名字：雷霆崖。 门徒岩们的本体了。 墨尔本CBD某处 说实话澳洲的城市繁华程度一般，特别是悉尼，可能是发展早了，直观感觉甚至不如墨尔本现代化程度高。所以嘛去澳洲拍街景意义不大，毕竟澳村嘛，就是要下乡。其实最重要的原因是看山看海几乎不要钱，逛街要钱 墨尔本住处附近的不知名海滩 没错又是他，最爱被拍的Doctor Liu。]]></content>
      <categories>
        <category>镜头后的视界</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>旅行</tag>
        <tag>澳洲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drops cast in Australia(上篇)]]></title>
    <url>%2F2018%2F06%2F16%2F%E9%95%9C%E5%A4%B4%E5%90%8E%E7%9A%84%E8%A7%86%E7%95%8C%2FDrops%20cast%20in%20Australia%2F</url>
    <content type="text"><![CDATA[毕设前后一直很忙，终于有时间闲下来整理一下在土澳交换的小半年随手累积的照片其实是有空我也没这个闲情整理哎。 难得身处澳村，有很好的机会取景，但是作为一个小白没有好的设备和拍摄技巧，所以所有照片都是随手即兴拍不曾预谋。设备是Samsung S8，多亏于爆炸星在去年算是顶尖的手机届成像水平，算是没有完全浪费这些取景机会吧。 这几天收到了旁友lxf借我的单反，小白穷人也是第一次摸单反，随手拍了几张和手机对比。个人感觉在单反出片不后期的情况下，近景方面我的手机通过自身软件处理的色彩是很棒的，可能偏暖一些，很讨喜。但是中远距离的风景照，就会被胖揍了，远处细节模糊，曝光不足导致背阳处黑成一片等等。这还是用的18-55mm的普通调焦镜头，没有上长焦镜头。 本来作为没有碰过单反的门外汉，以为手机端摄影已经很厉害了，现在做了小实验才发现自己实在是naive。以后真的要攒钱买单反了，很想入坑。 索尼康游会稽，渡浙江，果与星俱观。星曰:”彼可取而代也。”果掩其口，曰:”毋妄言，吾等爪机尚嫩也!” 以下，照片奉上。 Swan Lake湖边 主干道的蓝花楹 物理学院楼前 St Thomas More College(我住的社区) 帆船之旅(feat. Doctor Liu &amp; 半个Tonny Liu) Perth Zoo &amp; aqarium 当时觉得孔雀的神态很有意思，但是它本身背阳都看不清了，只有一个剪影。幸亏当时没有舍弃按下快门的想法。刚才现学了一下PS，给孔雀身体部分加了曝光度。虽然看上去还有点诡异。。。 Margret River附近 一家酒庄前。 Perth CBD中的一个复古小巷子 这篇花了我近三个小时。起初是发现浏览器会自动把我竖着拍的图片旋转，需要用PS去掉图片的exif信息消除旋转。于是不会PS的我下载了PS，居然有内置新手教学，愉快地跟着学了一波，掌握了最最最基础的几个技巧，开始修图。这篇的图有一半是稍微修过一点的，大部分几乎是原图，毕竟是刚学的PS，orz。那张孔雀的就是因为技巧还太嫩，所以看着仍然有点违和。 西澳部分结束~下一篇是东澳部分（墨尔本和悉尼）。]]></content>
      <categories>
        <category>镜头后的视界</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>旅行</tag>
        <tag>澳洲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在最初]]></title>
    <url>%2F2018%2F06%2F16%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2F%E5%86%99%E5%9C%A8%E6%9C%80%E5%88%9D%2F</url>
    <content type="text"><![CDATA[Nice to meet you现在是2018年6月11日，博主josh本科即将毕业，做完毕设之后在实验室跟着师兄们学习。 起初是看到同一个实验室同一届刘FR同学的blog。如果说博客是人心灵的窗户，那么第一次看到他的主页真的是顿感窗明几净，直达灵魂，让我这个糙汉都心生向往之情。 算了不吹他了，做个老实人 自己平时有记笔记的习惯，主要工具是onenote。一直觉得onenote是好用，尤其是搭配surface的4096压感触控笔写写画画什么的，就是排版还是有些麻烦，还有就是字体经常莫名其妙切换掉之类的。 直到看到有markdown语法，免去了排版的琐碎，还能直接在hexo搭建的博客上面发布.md文件。不如以后就用markdown记笔记，稍加整理之后还可以发到博客上，nide兄嘚！ 学了一下怎么搭建站点，然后发布这个第一篇文章。 今后可能有以下一些内容会维持更新： about learning 论文阅读笔记 系统，网络，数学方面的专业知识点梳理 源码分析 about life 杂记 读书笔记 旅行见闻说得你有空有钱一样 about you 欢迎常来看看，一起交流这个√自己就不打啦]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>序言</tag>
      </tags>
  </entry>
</search>
